---
title: NOI2024 前模拟赛
date: 2024-05-07 20:56:19
tags:
	- 校内
	- 模拟赛
categories: 学习笔记
---
# 练功
练内功。
## 5.7

$13/100+0/100+3/3$

怎么有人文件都不会写了。

### T1

#### 题面

求方程 $Ax^2+Bxy+Cy^2+Dx+Ey\equiv 0 \pmod P$ 的 $M$ 个根，保证 $D>0$。

多测，$\sum M\leq 5\times 10^5$，$P>>M$。

#### Sol
考虑一个观察：限制非常的宽，如果我们随机给这些方程加一些限制，然后尝试解出这个方程（可能无解或重复），期望 $O(M)$ 次就可以得到 $M$ 个本质不同的解。这一步需要一定的胆子和数学直觉。

一种做法是枚举 $x$，解关于 $y$ 的二次方程，但是需要算二次剩余。

还有一种做法是钦定 $y=kx$，然后枚举这个 $k$ 解关于 $x$ 的二次方程，注意到 $x=0$ 是这个方程的一个根，则另一个根可以直接通过韦达定理计算，无需解二次剩余。

这种做法的几何意义是枚举一条斜率为整数的直线，交这个椭圆一定能得到一个有理点。


### T2

#### 题面

记 $[n]={0,1,2,\ldots,n}$。

求：

$$\sum_{r=0}^{n-1}\bigg(\sum_{S\sube [nm-1]}\bigg[\bigg(\sum_{x\in S}x\bigg)\equiv r\pmod n\bigg]\bigg)^2$$

多测，$T\neq 50$，$1\leq n,m\leq 10^{12}$。

#### Sol

看到平方，先组合意义一下。

相当于选两个集合使得他们元素总和模 $n$ 相等，也就是两个集合元素总和作差模 $n$ 余 $0$，注意到我们是在模意义下计算作差，因此可以变成选两个集合，总和模 $n$ 余 $0$。

这相当于是 $0\sim n-1$，每个数字出现了 $2m$ 次的背包，求最后总和模 $n$ 余 $0$ 的方案数。

也就是求：

$$[x^0]\prod_{i=0}^{n-1}(1+x^i)^{2m} \bmod (x^n-1)$$

直接考虑单位根反演：

$$\dfrac{1}{n}\sum_{i=0}^{n-1}\prod_{j=0}^{n-1}(1+\omega_{n}^{ij})^{2m}$$

考虑 $ij\bmod n$ 的序列，发现只与 $\gcd(i,n)$ 有关。

那么可以枚举这个 $\gcd$，得到：

$$\dfrac{1}{n}\sum_{d|n} \varphi(d)\prod_{i=0}^{d-1}(1+\omega_d^{i})^{2m\frac{n}{d}}$$

考虑计算 $\prod_{i=0}^{n-1}(1+\omega_{n}^i)$。

这个式子有结论：其值为 $1+(-1)^{n-1}$。

到这里就可以直接枚举约数直接算了，复杂度为 $\mathcal{O}(T(\sqrt{n}+d(n)\log(n)))$。

使用 Pollard-Rho 分解质因数配合计算 $2$ 的光速幂可以做到 $\mathcal{O}(\sqrt{P}+T(n^{\frac{1}{4}}+d(n)))$，但是没有必要。

如何算 $\prod_{i=0}^{n-1}(1+\omega_{n}^i)$？

注意到我们有：

$$x^n-1=\prod_{i=0}^{n-1}(x-\omega_{n}^{i})$$

直接代入 $x=-1$ 就可以得到结论。

**看到题中（尤其是数数题）里有取模相关一定要考虑单位根啊啊啊啊啊啊啊啊。**

还有一种手法是推导原多项式 DFT 后的结果，与这种方法并无多大差别。

### T3

#### 题面

Luogu P7729

#### Sol

太困难了。

具体地想法是维护出第一问的答案，发现一定是若干个连通块不动，剩下一个连通块变化一条边，然后找出最小环可以维护第一问，第二问不会。

最小环 $\mathcal{O}(nm)$ 可以建出 BFS 树然后考虑最多只有一条边不在树上。


## 5.11

$100/100+5/100+12/52$

越打越唐，T1 T2 都是挺顺的题。

现在思维不知道怎么容易寸止了。

### T1

#### 题面

称一个正整数序列是好的，当且仅当所有真前缀和与真后缀和两两不同。

给定 $n$ 和 $n$ 个限制 $l_i,r_i$。计算有多少长度为 $n$ 的序列，满足每个数 $a_i$ 在 $[l_i,r_i]$ 之间且是好的。

$1\leq n\leq 50,1\leq l_i\leq r_1\leq 2000$。

#### Sol

首先我们只需要判断任意不交的前后缀。

因为数字都是正整数，所以前缀和序列和后缀和序列都单调。

考虑一个 check，将这两个序列归并起来，这样只需要比较归并后的序列相邻元素。

由此设 dp 状态，设 $f_{l,r,sl,sr}$ 表示填完 $l$ 前缀，前缀和为 $sl$，填完了 $r$ 后缀，后缀和为 $sr$。要求不能有 $sl=sr$。如果 $sl<sr$ 那就先填前缀，否则先填后缀（哪边小动哪边，符合归并的流程）状态数 $\mathcal{O}(n^4V^2)$。

注意到我们只需要知道 $sl$ 和 $sr$ 的大小关系，那就记录只记录差值 $dt=sl-sr$，根据刚才的填数过程显然有 $|dt|\leq \max r_i$，这样状态数就只有 $\mathcal{O}(n^2V)$ 了，使用前缀和来进行转移，复杂度 $\mathcal{O}(n^2V)$。 

### T2

#### 题面

称一个长为 $n$ 的正整数序列 $p$ 是坏的，当且仅当：

$$\forall 1<i\leq n, |p_i-p_{i-1}|\leq k$$

给出一个长为 $n$ 的正整数序列 $a$，以及三个数 $m,l,k$，满足 $1\leq a_i\leq m$。

你需要找出一个最长的序列 $b$，满足：

1. $1\leq b_i\leq m$。
2. $a$ 是 $b$ 的前缀。
3. $b$ 中不存在长度超过 $l$ 的坏子序列。

$1\leq n\leq 2\times 10^5,1\leq m,l,k\leq 10^9$。

#### Sol

考虑坏子序列的 dp，设 $f_v$ 表示以数字 $v$ 结尾的最长坏子序列，那么每次加入一个数字的转移就是 $f_v=\max\limits_{i=v-k}^{v+k}f_i+1$，我们可以上个线段树预处理出只考虑 $a$ 时的 $f$ 数组。

接下来放新的数字的时候考虑一个贪心，每次找出一个 $x$，使得放上这个 $x$ 后的 $f_x$ 最小，且这个 $f_x$ 尽可能靠边。

这个贪心显然正确性没有问题，直接做的话可以得到一个复杂度为 $\mathcal{O}(ans\times m\log m)$ 的做法，其中 $ans$ 为 $\mathcal{O}(kl)$ 级别。

这个东西复杂度有点大，尤其是还有一个枚举 $x$ 是什么，考虑把 dp 从刷表改成填表，即设 $g_i$ 表示我目前假装我要放在 $i$ 位置，那么新的 $f_i$ 应该是多少。然后每次放完一个数字后，$g$ 的维护就是一段区间取 $\max$。这样子可以做到复杂度为 $\mathcal{O}(ans\log m)$。

考虑上面这个过程实际上干了什么，在初始做完 $a$ 数组的 dp 后，$g$ 内应该是有不超过 $n$ 个连续段。每次找出权值最小的连续段，设其长度为 $L$，操作 $\lceil\frac{L}{K}\rceil$ 次后这个连续段的权值加一。

那么就可以逐连续段考虑，每次让它和两边更小的合并起来算贡献，最后只剩下一个连续段的时候直接算答案（退化为了 $n=0$ 的情况）显然枚举的连续段个数是 $\mathcal{O}(n)$ 的。

总复杂度 $\mathcal{O}(n\log m)$，如果离散化就是 $\mathcal{O}(n\log n)$。

### T3

#### 题面

给出 $n,k$，计算：

$$\sum_{i=1}^{n}\operatorname{lcm}(i,i+1,i+2,\ldots,i+k)$$

#### Sol

老题新放是吧/qd

考虑设 $\dfrac{x^{\overline{k+1}}}{\operatorname{lcm}(x,x+1,x+2,\ldots,x+k)}=C$。

对于 $C$ 值相等的 $x$ 我们显然可以放在一起插值计算前缀和，最后把所有 $n$ 以内不同 $C$ 值的答案加起来。

这里有一个结论，设 $K=\operatorname{lcm}(1,2,3,\ldots,k)$，则所有 $x$ 模 $K$ 同余的位置 $C$ 相等。

那么直接枚举 $x$ 模 $K$ 的余数硬插。复杂度 $\mathcal{O}(K\mathrm{poly}(k))$。
