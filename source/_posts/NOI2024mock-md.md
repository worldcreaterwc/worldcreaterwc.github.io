---
title: NOI2024 前模拟赛
date: 2024-05-07 20:56:19
tags:
	- 校内
	- 模拟赛
categories: 学习笔记
---
# 练功
练内功。
## 5.7

$13/100+0/100+3/3$

怎么有人文件都不会写了。

### T1

#### 题面

求方程 $Ax^2+Bxy+Cy^2+Dx+Ey\equiv 0 \pmod P$ 的 $M$ 个根，保证 $D>0$。

多测，$\sum M\leq 5\times 10^5$，$P>>M$。

#### Sol
考虑一个观察：限制非常的宽，如果我们随机给这些方程加一些限制，然后尝试解出这个方程（可能无解或重复），期望 $O(M)$ 次就可以得到 $M$ 个本质不同的解。这一步需要一定的胆子和数学直觉。

一种做法是枚举 $x$，解关于 $y$ 的二次方程，但是需要算二次剩余。

还有一种做法是钦定 $y=kx$，然后枚举这个 $k$ 解关于 $x$ 的二次方程，注意到 $x=0$ 是这个方程的一个根，则另一个根可以直接通过韦达定理计算，无需解二次剩余。

这种做法的几何意义是枚举一条斜率为整数的直线，交这个椭圆一定能得到一个有理点。


### T2

#### 题面

记 $[n]={0,1,2,\ldots,n}$。

求：

$$\sum_{r=0}^{n-1}\bigg(\sum_{S\sube [nm-1]}\bigg[\bigg(\sum_{x\in S}x\bigg)\equiv r\pmod n\bigg]\bigg)^2$$

多测，$T\neq 50$，$1\leq n,m\leq 10^{12}$。

#### Sol

看到平方，先组合意义一下。

相当于选两个集合使得他们元素总和模 $n$ 相等，也就是两个集合元素总和作差模 $n$ 余 $0$，注意到我们是在模意义下计算作差，因此可以变成选两个集合，总和模 $n$ 余 $0$。

这相当于是 $0\sim n-1$，每个数字出现了 $2m$ 次的背包，求最后总和模 $n$ 余 $0$ 的方案数。

也就是求：

$$[x^0]\prod_{i=0}^{n-1}(1+x^i)^{2m} \bmod (x^n-1)$$

直接考虑单位根反演：

$$\dfrac{1}{n}\sum_{i=0}^{n-1}\prod_{j=0}^{n-1}(1+\omega_{n}^{ij})^{2m}$$

考虑 $ij\bmod n$ 的序列，发现只与 $\gcd(i,n)$ 有关。

那么可以枚举这个 $\gcd$，得到：

$$\dfrac{1}{n}\sum_{d|n} \varphi(d)\prod_{i=0}^{d-1}(1+\omega_d^{i})^{2m\frac{n}{d}}$$

考虑计算 $\prod_{i=0}^{n-1}(1+\omega_{n}^i)$。

这个式子有结论：其值为 $1+(-1)^{n-1}$。

到这里就可以直接枚举约数直接算了，复杂度为 $\mathcal{O}(T(\sqrt{n}+d(n)\log(n)))$。

使用 Pollard-Rho 分解质因数配合计算 $2$ 的光速幂可以做到 $\mathcal{O}(\sqrt{P}+T(n^{\frac{1}{4}}+d(n)))$，但是没有必要。

如何算 $\prod_{i=0}^{n-1}(1+\omega_{n}^i)$？

注意到我们有：

$$x^n-1=\prod_{i=0}^{n-1}(x-\omega_{n}^{i})$$

直接代入 $x=-1$ 就可以得到结论。

**看到题中（尤其是数数题）里有取模相关一定要考虑单位根啊啊啊啊啊啊啊啊。**

还有一种手法是推导原多项式 DFT 后的结果，与这种方法并无多大差别。

### T3

#### 题面

Luogu P7729

#### Sol

太困难了。

具体地想法是维护出第一问的答案，发现一定是若干个连通块不动，剩下一个连通块变化一条边，然后找出最小环可以维护第一问，第二问不会。

最小环 $\mathcal{O}(nm)$ 可以建出 BFS 树然后考虑最多只有一条边不在树上。


## 5.11

$100/100+5/100+12/52$

越打越唐，T1 T2 都是挺顺的题。

现在思维不知道怎么容易寸止了。

### T1

#### 题面

称一个正整数序列是好的，当且仅当所有真前缀和与真后缀和两两不同。

给定 $n$ 和 $n$ 个限制 $l_i,r_i$。计算有多少长度为 $n$ 的序列，满足每个数 $a_i$ 在 $[l_i,r_i]$ 之间且是好的。

$1\leq n\leq 50,1\leq l_i\leq r_1\leq 2000$。

#### Sol

首先我们只需要判断任意不交的前后缀。

因为数字都是正整数，所以前缀和序列和后缀和序列都单调。

考虑一个 check，将这两个序列归并起来，这样只需要比较归并后的序列相邻元素。

由此设 dp 状态，设 $f_{l,r,sl,sr}$ 表示填完 $l$ 前缀，前缀和为 $sl$，填完了 $r$ 后缀，后缀和为 $sr$。要求不能有 $sl=sr$。如果 $sl<sr$ 那就先填前缀，否则先填后缀（哪边小动哪边，符合归并的流程）状态数 $\mathcal{O}(n^4V^2)$。

注意到我们只需要知道 $sl$ 和 $sr$ 的大小关系，那就记录只记录差值 $dt=sl-sr$，根据刚才的填数过程显然有 $|dt|\leq \max r_i$，这样状态数就只有 $\mathcal{O}(n^2V)$ 了，使用前缀和来进行转移，复杂度 $\mathcal{O}(n^2V)$。 

### T2

#### 题面

称一个长为 $n$ 的正整数序列 $p$ 是坏的，当且仅当：

$$\forall 1<i\leq n, |p_i-p_{i-1}|\leq k$$

给出一个长为 $n$ 的正整数序列 $a$，以及三个数 $m,l,k$，满足 $1\leq a_i\leq m$。

你需要找出一个最长的序列 $b$，满足：

1. $1\leq b_i\leq m$。
2. $a$ 是 $b$ 的前缀。
3. $b$ 中不存在长度超过 $l$ 的坏子序列。

$1\leq n\leq 2\times 10^5,1\leq m,l,k\leq 10^9$。

#### Sol

考虑坏子序列的 dp，设 $f_v$ 表示以数字 $v$ 结尾的最长坏子序列，那么每次加入一个数字的转移就是 $f_v=\max\limits_{i=v-k}^{v+k}f_i+1$，我们可以上个线段树预处理出只考虑 $a$ 时的 $f$ 数组。

接下来放新的数字的时候考虑一个贪心，每次找出一个 $x$，使得放上这个 $x$ 后的 $f_x$ 最小，且这个 $f_x$ 尽可能靠边。

这个贪心显然正确性没有问题，直接做的话可以得到一个复杂度为 $\mathcal{O}(ans\times m\log m)$ 的做法，其中 $ans$ 为 $\mathcal{O}(kl)$ 级别。

这个东西复杂度有点大，尤其是还有一个枚举 $x$ 是什么，考虑把 dp 从刷表改成填表，即设 $g_i$ 表示我目前假装我要放在 $i$ 位置，那么新的 $f_i$ 应该是多少。然后每次放完一个数字后，$g$ 的维护就是一段区间取 $\max$。这样子可以做到复杂度为 $\mathcal{O}(ans\log m)$。

考虑上面这个过程实际上干了什么，在初始做完 $a$ 数组的 dp 后，$g$ 内应该是有不超过 $n$ 个连续段。每次找出权值最小的连续段，设其长度为 $L$，操作 $\lceil\frac{L}{K}\rceil$ 次后这个连续段的权值加一。

那么就可以逐连续段考虑，每次让它和两边更小的合并起来算贡献，最后只剩下一个连续段的时候直接算答案（退化为了 $n=0$ 的情况）显然枚举的连续段个数是 $\mathcal{O}(n)$ 的。

总复杂度 $\mathcal{O}(n\log m)$，如果离散化就是 $\mathcal{O}(n\log n)$。

### T3

#### 题面

给出 $n,k$，计算：

$$\sum_{i=1}^{n}\operatorname{lcm}(i,i+1,i+2,\ldots,i+k)$$

#### Sol

老题新放是吧/qd

考虑设 $\dfrac{x^{\overline{k+1}}}{\operatorname{lcm}(x,x+1,x+2,\ldots,x+k)}=C$。

对于 $C$ 值相等的 $x$ 我们显然可以放在一起插值计算前缀和，最后把所有 $n$ 以内不同 $C$ 值的答案加起来。

这里有一个结论，设 $K=\operatorname{lcm}(1,2,3,\ldots,k)$，则所有 $x$ 模 $K$ 同余的位置 $C$ 相等。

那么直接枚举 $x$ 模 $K$ 的余数硬插。复杂度 $\mathcal{O}(K\mathrm{poly}(k))$。

## 5.22

$0/100+60/100+0/100=60$

我是睡觉高手。

### T1

给定一张网格图，其中某些节点有障碍，你每次只能向右向下走，要从 $(0,0)$ 走到 $(n,m)$，你需要选出数量最大的路径集合，使得集合中不存在两条路径，其中一条穿过了另一条。

这里两个路径不同，当且仅当存在一个障碍，一条路径经过了这个障碍的上方，另一条经过了下方。

$1\leq n,m\leq 2000$。

### Sol

考虑原先障碍构成的连通块形状比较奇怪不好分析，所以我们先把不能从起点到达的点，或者不能到达终点的点也视作障碍，这样就舒服多了。

然后单独长在边缘上的连通块没用，把它们扔掉，接下来有结论：答案等于剩下的连通块数加一。

貌似是直接调整能够得到这个结论？

## T2

### 题面

老鼠进洞，但是每个位置有多个老鼠，每个洞也可以进多个老鼠。

$n\leq 5\times 10^5$，时限 3s。

### Sol

你注意到朴素老鼠进洞是开两个堆不断弹弹弹，把弹出去的东西扔到另一个堆里，那你就把堆换成一个平衡树加速弹弹弹，写了一下发现过了。

题解分析这玩意是因为每次取出堆扔到另一个堆的过程是中，合并的部分不会有交，但是感觉不是特别有道理。

另一种做法是考虑 dp，设 $f_i,j$ 表示当前在当前位置，前面匹配掉的老鼠减去洞的数量为 $j$ 是的答案，这个东西肯定是凸的，所以来个 slope trick 优化转移。

std 是怎么考虑的呢？注意到原问题本身是一个线性规划问题，考虑对其进行对偶，**对偶的时候尽可能少的保留变量，尽可能对着原问题对偶，不要去对偶费用流图，这样会很麻烦。**

对偶后的问题可以模拟费用流解决，你先别急，让我想想怎么对偶。

**启示：对于线性规划性问题，对偶是一个很好的解决办法。**

## T3

### 题面

给出一个字符串集合 $S$，大小为 $n$，每个串长度不超过 $m$，问你从一个串 $T$ 开始，每次随机以 $p_i$ 的概率加入字符 $i$，期望多少步可以得到 $S$ 中的某个串。

$n\leq 100,n\times m\leq 10^4$。

### Sol

暴力做法就是考虑建出 AC 自动机，然后高斯消元，复杂度是 $\mathcal{O}((nm)^3)$ 的。

发现解方程的过程不可避免，那么考虑怎么减少未知数的数量。

**AC 自动机的一个显然的性质：所有转移边要么指向自己在 trie 上的儿子，要么指向比自己深度低的节点。**

观察方程：$E(x)=1+\sum\limits_{i\in \Sigma} p_iE(\delta_{x,i})$，如果我们已经知道了所有深度比 $x$ 低的节点的表示，且 $x$ 在 trie 上只有一个儿子，那么我们可以直接得出这个儿子的表示。

如果 $x$ 在 trie 上有多于一个儿子怎么办？随便选一个儿子，对另外的儿子设位置变量来表示出我选的儿子。

用 bfs 的方法一层一层的把表示推出来，最后利用终点答案为 $0$ 列出方程。

这样做法本质上是对 trie 进行实链剖分，那么变量就是虚儿子的数量（也就是实链的数量），而实链数量为叶子数量，这个只有 $n$ 个，因此再做高斯消元复杂度就对了。

总复杂度 $\mathcal{O}(n^3+n^2m)$。

好题，利用了 AC 自动机的性质去下降高斯消元的未知数个数（叶子个数少以及可以 bfs 一层一层推算）。